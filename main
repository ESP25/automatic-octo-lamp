#include "mbed.h" 
#include "QEI.h"
#include "C12832.h"
#include "PID.h"
#include "math.h"
#define RATE 0.1 //corresponds to 0.2 seconds
#define BASE 300
#define TIMEOUT 1.0
 
C12832 lcd(PA_7, PA_5, PA_6, PA_8, PB_6); 

DigitalOut enable(PA_15);  
DigitalOut bipolar_one(PB_7); 
DigitalOut bipolar_two(PC_13); 
DigitalOut direction_one(PB_12);
DigitalOut direction_two(PA_13);
InterruptIn user_toggle(PB_5);  //Start button
PwmOut pwm_one(PC_8); 
PwmOut pwm_two(PA_11);

QEI wheel_one(PC_10, PC_12, NC, 256); //These are placeholders
QEI wheel_two(PC_11, PD_2, NC, 256); //These are placeholders


PID left_control(1.0, 0.0, 0.0, RATE); //play with different rates
PID right_control(1.0, 0.0, 0.0, RATE); //play with different rates

Ticker wheels;

//Motor Configuration
int M_1_bipolar = 0;
int M_1_direction = 1; // 1 goes forwards right motor
int M_2_bipolar = 0;
int M_2_direction = 0;  // 0 goes forwards left motor
int sys_state = 0; //system state (1 = motor on, 0 = motor off)

int left_pulses = 0; //left motor pulses
int right_pulses = 0; //right motor pulses

int left_pulses_prev = 0; 
int right_pulses_prev = 0; 

float left_velocity = 0.0;
float right_velocity = 0.0;

float left_duty = 0; //duty cycle of the right motor
float right_duty = 0; //duty cycle of the right motor

float left_setpoint = BASE; //what the PID control works on eventually
float right_setpoint = BASE; //JUST A PLACEHOLDER. THIS HAS TO BE CHOSEN BY THE GROUP


void system(void){ //controlled by the joystick this toggles the motor on/off
   sys_state = !sys_state;
       if(sys_state){
           enable = 1;
            }
       else{
          enable = 0;  
            }
}
void pwm_frequency(int frequency){ //to simplify calculations and setup
    int period = 1000000 / frequency; //in microseconds
    pwm_one.period_us(period); 
    pwm_two.period_us(period); 
}
void left_motor(float duty){ 
  //since the motors have an inverted duty cycle, this simplifies this in software
    pwm_one.write(float(1.0) - duty);
}
void right_motor(float duty){ 
    //same as above
    pwm_two.write(float(1.0) - duty);
}
void stop(void){ //a specific stop function to override the motor control and to be used by the Watch Dog Timer
    
    j = 1;
    sys_state = 0;
    left_motor(0);
    right_motor(0);
}
void motor_setup(void){//The following are set irrespective if the motor board is on or off and are later based on the PID control
  enable = 0; //Sets enable to zero ahead of user input
  bipolar_one = M_1_bipolar;
  bipolar_two = M_2_bipolar;
  direction_one = M_1_direction;
  direction_two = M_2_direction;
   
  //SETUP OF PWM
  pwm_frequency(5000);
}

void PID_setup(void){ //tuning and work on parameters
  left_control.setInputLimits(0.0, 870); //max to be determined in experiment
  left_control.setOutputLimits(0.0, 0.9);
  left_control.setMode(AUTO_MODE); //sets to auto (manual used later to override control)
  left_control.setSetPoint(left_setpoint); //in terms of pulses

  right_control.setInputLimits(0.0, 900); //max to be determined in experiment
  right_control.setOutputLimits(0.0, 0.9);
  right_control.setMode(AUTO_MODE); //sets to auto
  right_control.setSetPoint(right_setpoint); //in terms of pulses
}

void wheel_PID(void){ 
    left_pulses = wheel_one.getPulses();
    left_velocity = (left_pulses - left_pulses_prev) / RATE;
    left_pulses_prev = left_pulses;
    left_control.setProcessValue(left_pulses);
    
    right_pulses = -1*wheel_two.getPulses();
    right_velocity = (right_pulses - right_pulses_prev) / RATE;
    right_pulses_prev = right_pulses;
    right_control.setProcessValue(right_pulses);

    left_motor(left_control.compute());
    right_motor(right_control.compute());
}


 
void visualise(void){
    lcd.cls();
    lcd.locate(0,0);
    lcd.printf("L: %f R: %f\nLA: %f RA: %f", left_setpoint, right_setpoint, left_velocity, right_velocity); //, diff, left_setpoint, right_setpoint)
}



int main(void){
  user_toggle.rise(&system); //When button is pressed, the state is toggled
  motor_setup();
  PID_setup();
  
  while(1){
    if(sys_state){
            wheel_PID();
            visualise();
            wait(RATE);
          }
        }
       
   return 0;         
}

