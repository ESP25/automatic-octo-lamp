#include "mbed.h" 
#include "C12832.h"
#include "PID.h"
#include "math.h"
#define RATE 0.1//corresponds to 0.1 seconds
#define BASE 300
#define TIMEOUT 1.0
 
C12832 lcd(PA_7, PA_5, PA_6, PA_8, PB_6); 

BusOut leds(PB_15, PB_2, PC_6, PA_12, PA_14); //LSB on the left to MSB on the right. Means byte will be 00654321
AnalogIn sensor[5] = {PB_1, PC_2, PC_3, PC_4,PC_5};
Ticker  wdt;
Ticker PID_caller;
InterruptIn mag(PC_14); //Input from comparator

PID navigation(1.0, 0.0, 0.0, RATE);

float left_duty = 0.0;
float right_duty = 0.0;
float left_setpoint = BASE; //what the PID control works on eventually
float right_setpoint = BASE; //JUST A PLACEHOLDER. THIS HAS TO BE CHOSEN BY THE GROUP
float data[5] = {0}; 
float temp = 0.0;
float threshold = 0.20;
int centre_flag = 0; //1 if centre sensor detects line

float direction = 0.0;
float offset = 0.0;
float steering_action = 0.0;

int sensor_iterate[5] = {0,2,4,1,3}; //Works
int sel = 0;
int wdt_state = 0;
int i = 0;

int j = 1;





void wdt_timeout(void){
    if (!wdt_state){
        j = 0;
        //stop(); //REQUIRES motor_control to be includes
    }
    wdt_state = 0; //resets the timer
}

void wdt_kick(void){
    wdt_state = 1; 
    //kicks the wdt
}

void visualise(void){
    lcd.cls();
    lcd.locate(0,0);
    //lcd.printf("%.2f %.2f %.2f %.2f %.2f\n%d", data[4], data[3], data[2], data[1], data[0], wdt_state);
    lcd.printf("O: %.1f SA: %.2f C: %d\n%.0f %.0f", offset, steering_action, centre_flag, left_setpoint, right_setpoint); 
}


void measure_sensors(void){ //0 is off, 1 is on
    for(i = 0; i < 5; i++){
       sel = sensor_iterate[i];
       temp = sensor[sel].read(); //why not sensor.read (which returns a float)

       if(temp >= float(threshold)){
          data[sel] = temp;
          wdt_kick();
       }
       else{
        data[sel] = temp / 10;
       }
    }
    if(data[2] >= 0.85){
      centre_flag = 1;
        }
    else{
      centre_flag = 0;
    }
     
}

void line_offset(void){ //positive is to the right. 10 units to the right is 1.8 cm. Function returns the average of the center leds
  measure_sensors();
  offset =  (data[4]*-20.0)+(data[3]*-10.0)+(data[2]*0)+(data[1]*10.0)+(data[0]*20.0);
    //offset is then fed into the PID control as a magnitude with direction deciding which way the motor differential leans
   
 }

void PID_setup(void){
    //tuning and work on parameters
    navigation.setInputLimits(-20.0, 0.0); //max to be determined in experiment
    navigation.setOutputLimits(0.0, 1.0);
    navigation.setMode(AUTO_MODE); //sets to auto (manual used later to override control)
    navigation.setSetPoint(0.0); //in terms of pulses
}

float enforce(float d){// enforces that the duty cycle stays inisde 0.0 - 1.0
    if(d < 0.0){
      return 0.0;
    }

    else if(d > 1.0){
      return 1.0;
    }

    else{
      return d;
    }
}

void navigation_PID(void){
    if(j){
        direction = copysign(1.0, offset);
    navigation.setProcessValue(-1.0*fabs(offset));
    steering_action = direction*navigation.compute();
    if(centre_flag){
    left_setpoint = BASE;
    right_setpoint = BASE;
  }
    else{
    left_setpoint = BASE*(1 - steering_action);
    right_setpoint = BASE*(1 + steering_action);
    }
    visualise();
  }
}



int main(){
  PID_setup();
  leds.write(31); //check this!!!!

 
  PID_caller.attach(&navigation_PID, RATE);

  wdt.attach(&wdt_timeout, TIMEOUT); //interaction with turnaround. Check documentation
  while(j){
        //navigation_PID();
        line_offset();
        //wait(RATE);      
  }


  //stop();
  lcd.cls();
  lcd.locate(0,0);
  lcd.printf("END OF TRACK");
  wait(10);
  return 0;
}
